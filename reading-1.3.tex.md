# Reading Questions - Section 1.3

1. If someone claims to have a comparison sorting algorithm (that is, an algorithm that sorts by comparing keys) that takes n steps for a list of size n, should you believe them? Give a clear and complete explanation of your reasoning.

1. Which of these are *in-place* sorting algorithms: insertion sort, bubble sort, selection sort, quick sort, and merge sort?

1. Hopefully you recall the *binary search* algorithm. Give one or two benefits of the algorithm (versus sequential search, for example) and one or two limitations of the algorithm.

1. Give an example of a situation where *string matching* can be used to solve a problem.

1. What is the difference between a *graph algorithm* and a *graph problem*. Give examples that clearly demonstrate the difference.

1. It could be claimed that many *combinatorial problems* are both easy to solve and difficult to solve at the same time. What can I possibly mean by this? How can they be both?

1. What makes *numerical problems* different than the other types of problems discussed in this section? There are at least two possible ways to answer this question (they are related, but slightly different).
