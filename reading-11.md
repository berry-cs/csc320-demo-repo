# Reading Questions - Section 11.1

1. Was Lord Kelvin wrong?


2. Explain what a *lower bound* is and why it is a useful concept.


3. What would a reasonable *trivial lower bound* be for a problem on a graph with n vertices and m edges?


4. What would the *information-theoretic lower bound* be for a problem that needs to assign to each of the n vertices of a graph a number between -a to a and also assign to each of the m edges a number between 1 and 32? (The idea being that we need to determine what each of these numbers is, but I am not specifying exactly how. But that should not affect your answer.)


5. Describe in your own words what an *adversary argument* for establishing a lower bound on any algorithm to solve a problem.


6. To show that P is at least as difficult to solve as Q, do you reduce P to Q, or Q to P? Clearly explain why.


7. Which problem is more difficult, *Euclidean minimum spanning tree* or *element uniqueness*? Explain.


<hr />

# Reading Questions - Section 11.2

1. Answer the following questions about decision trees.
    - What is in each node?

    - What does the height of the tree tell you (relative to the problem/algorithm being analyzed)?

    - What has to be true about the number of leaves of the tree (relative to the problem/algorithm being analyzed)?



2. Explain why the possible number of outcomes of a sorting algorithm is <img src="svgs/50c0357224674ab662b8ea5e5ca3eb8a.svg?invert_in_darkmode" align=middle width=14.433101099999991pt height=22.831056599999986pt/>.



<hr />

# Reading Questions - Section 11.3

1. Name three *tractable* problems (you can't use any of those listed on page 402).


2. Name one or two *intractable* problems.


3. Technically speaking, is *sorting* in P? Explain.


4. What is the difference between *tractable/intractable* and *decidable/undecidable*?


5. Are *Hamiltonian circuit* and *traveling salesman* problems intractable? Explain.


6. What is the most important open question in theoretical computer science?


7. Would we rather it be the case that P = NP or that P â‰  NP? Explain.


8. What does it mean that the problems in NP-complete are the most difficult problems in NP? Be specific.


9. What do you need to do to prove that a problem is in NP-complete? (Hint: you need to do 2 things.)


10. What would it mean if I could find a polynomial-time algorithm to solve *Hamiltonian circuit*? I mean, would it be a bad thing, a good thing, or a very good thing? Explain.


