# Reading Questions - Section 7.1

1. Is *ComparisonCountingSort* a useful algorithm?


2. In the *DistributionCountingSort* algorithm, why does it matter whether or not we copy the values into a new array or the original array?


3. Even though the name should make it somewhat obvious, give a clear explanation of the idea behind the *space and time trade-off* technique.


<hr />

# Reading Questions - Section 7.2

1. Is it possible for Horspool’s algorithm to make more character comparisons than the brute-force algorithm would make in searching for the same pattern in the same text? (Hint: try a worst-case input for Horspool's algorithm.)


2. Would the Boyer-Moore algorithm work correctly with just the bad-symbol table to guide pattern shifts?


3. Would the Boyer-Moore algorithm work correctly with just the good-suffix table to guide pattern shifts?


<hr />

# Reading Questions - Section 7.3

1. Why is it not a good idea for a hash function to depend on just one letter (say, the first one) of a natural-language word?


2. Explain the difference in your own words between the two principal mechanisms for collision resolution.


3. Hashing is presented in the context of techniques based on space—time trade-offs. But it also takes advantage of another general strategy. Which one? (Look through the table of contents.)


<hr />

# Reading Questions - Section 7.4

1. When analyzing data structures such as arrays and trees, we usually care about the number of key comparisons used to perform an operation (e.g. search). With B-trees this is not what we care about. What do we care about instead and why?


2. Would you use linear search or binary search in a node of a B-tree with m=5? What about m=1000? Justify your answers. More generally, for what values of m (if any) would it be reasonable to use binary search?

